### What is JWT in Java Spring Boot Security?

**JWT (JSON Web Token)** is a compact, self-contained means of securely transmitting information between parties as a JSON object. This information is verifiable and trusted because it is digitally signed. In the context of **Spring Boot Security**, JWT is commonly used to implement stateless authentication for REST APIs.

---

#### Key Components of JWT

1. **Header**:
   - Specifies the type of token (`JWT`) and the signing algorithm (e.g., `HS256`).
   - Example:
     ```json
     {
       "alg": "HS256",
       "typ": "JWT"
     }
     ```

2. **Payload**:
   - Contains claims or data, such as user information and metadata.
   - Example:
     ```json
     {
       "sub": "user@example.com",
       "roles": ["USER"],
       "iat": 1672531200,
       "exp": 1672534800
     }
     ```

3. **Signature**:
   - Ensures the token's integrity. It is generated by signing the header and payload using a secret key.
   - Example (using HMAC SHA-256):
     ```
     HMACSHA256(
       base64UrlEncode(header) + "." +
       base64UrlEncode(payload),
       secret
     )
     ```

A complete JWT looks like this:
```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c2VyQGV4YW1wbGUuY29tIiwicm9sZXMiOlsiVVNFUiJdLCJpYXQiOjE2NzI1MzEyMDAsImV4cCI6MTY3MjUzNDgwMH0.GweGON_3lUBY8jXtOwG5OY44hMdC5zAqowJvBlbUY5E
```

---

#### Why Use JWT?

1. **Stateless**:
   - JWT eliminates the need for server-side session storage.
   - All user authentication data is encapsulated in the token itself.

2. **Secure**:
   - It uses cryptographic algorithms for signing, ensuring data integrity and authenticity.

3. **Compact**:
   - Suitable for transmitting in HTTP headers or as URL parameters.

4. **Scalable**:
   - Ideal for distributed applications (e.g., microservices).

---

#### Example: Implementing JWT in Spring Boot Security

##### Maven Dependencies

Add the following dependencies for Spring Security and JWT:

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-api</artifactId>
    <version>0.11.5</version>
</dependency>
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-impl</artifactId>
    <version>0.11.5</version>
    <scope>runtime</scope>
</dependency>
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-jackson</artifactId>
    <version>0.11.5</version>
    <scope>runtime</scope>
</dependency>
```

---

##### Configuration

###### Security Configuration

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http.csrf().disable()
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/auth/**").permitAll()
                .anyRequest().authenticated()
            );
        return http.build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration configuration) throws Exception {
        return configuration.getAuthenticationManager();
    }
}
```

---

###### JWT Utility

```java
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.security.Keys;
import org.springframework.stereotype.Component;

import java.security.Key;
import java.util.Date;

@Component
public class JwtUtil {

    private final Key secretKey = Keys.secretKeyFor(SignatureAlgorithm.HS256);
    private final long expirationMs = 3600000; // 1 hour

    public String generateToken(String username) {
        return Jwts.builder()
                .setSubject(username)
                .setIssuedAt(new Date())
                .setExpiration(new Date(System.currentTimeMillis() + expirationMs))
                .signWith(secretKey)
                .compact();
    }

    public String extractUsername(String token) {
        return Jwts.parserBuilder()
                .setSigningKey(secretKey)
                .build()
                .parseClaimsJws(token)
                .getBody()
                .getSubject();
    }
}
```

---

###### Authentication Controller

```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.userdetails.User;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/auth")
public class AuthController {

    @Autowired
    private AuthenticationManager authenticationManager;

    @Autowired
    private JwtUtil jwtUtil;

    @PostMapping("/login")
    public String login(@RequestParam String username, @RequestParam String password) {
        Authentication authentication = authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(username, password)
        );

        User user = (User) authentication.getPrincipal();
        return jwtUtil.generateToken(user.getUsername());
    }
}
```

---

###### Secured Endpoint

```java
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class SecuredController {

    @GetMapping("/secured")
    public String securedEndpoint(@RequestHeader("Authorization") String authHeader) {
        String token = authHeader.replace("Bearer ", "");
        // Token can be verified here using JwtUtil if needed
        return "You have accessed a secured endpoint!";
    }
}
```

---

##### Application Properties

```properties
server.port=8080
```

---

#### How It Works

1. **Login Endpoint**:
   - User sends a POST request to `/auth/login` with their credentials.
   - The application authenticates the user and returns a JWT token.

2. **Secured Endpoint**:
   - The user sends the JWT token in the `Authorization` header (`Bearer <token>`).
   - The token is validated, and access is granted.

3. **Stateless**:
   - No server-side sessions are stored. The client uses the token to prove authentication.

---

#### Example Workflow

1. **Login Request**:
   ```bash
   curl -X POST -d "username=user&password=password" http://localhost:8080/auth/login
   ```
   Response:
   ```json
   {
     "token": "eyJhbGciOiJIUzI1NiIsInR..."
   }
   ```

2. **Access Secured Endpoint**:
   ```bash
   curl -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR..." http://localhost:8080/secured
   ```
   Response:
   ```
   You have accessed a secured endpoint!
   ```

---

This implementation demonstrates how JWT provides stateless, scalable authentication in Spring Boot Security.